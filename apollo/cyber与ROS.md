# NOTE
 
## ROS
[百度apollo 3.5是如何设计cyber RT计算框架的？](https://t.cj.sina.com.cn/articles/view/6080368657/16a6b101101900fpdw?sudaref=www.google.com&display=0&retcode=0)
### 自动驾驶也相当于一个大的机器人
1. 通信系统，ROS是分布式的松耦合，算法模块以独立的进程形式存在。ROS基于Socket实现了pub/sub的通信方式;
2. framework & tools: 框架和工具，开发者可以基于ROS提供的client library和通信层，方便地收发消息。开发者只需要关注消息处理相关的算法，至于算法何时被调用，全部由框架来处理
3. 生态系统好，开发者可以方便地找到很多现成的传感器驱动和算法实现
### ROS存在的问题
1. ROS中的算法模块是以独立的进程形式存在，这些进程之间执行顺序并无任何逻辑。linux内核调度器更不清楚，其调度只是在尽量满足公平的情况下让大家得到调度。
2. 在ROS中添加调度的node，或者在linux内核实现新的调度策略，都会存在问题，前者是开销，后者是移植性
3. ROS是一个分布式的系统，分布式就会有通信的开销。前期使用共享内存和DDS解决通信方面的实时性，ROS也支持Nodelet模式，降低开销
4. ROS中还存在很多的不确定性，比如内存的的动态申请

## CYBER RT
1. 算法模块通过有向无环图(DAG),配置任务间的逻辑关系。对于每个算法有其优先级、运行时间、使用资源等方面的配置。系统启动时，结合DAG，调度配置等，创建相应的任务，从框架内部讲就是协程，调度器把任务放到各个processor的队列中。然后由各个sensor输入的数据驱动整个系统运转。
2. 为了高效，cyber rt实现了自己的基础库。希望cyber rt减少依赖
3. 支持跨机跨进程，上层无需关心，通信层自动根据算法模块的部署，自动选择相应的通信机制
4. 通信层上是数据缓存/融合层，多路传感器之间数据需要融合，而且算法可能需要缓存一定的数据。
5. 再网上是计算模型，将调度、任务从内核空间搬运到了用户空间。调度可以和算法业务逻辑紧密结合。任务编排，策略是 Cyber RT 开源的主要策略之一。每个 Processor (Native Thread) 一个任务队列，由调度器编排队列中的任务。任务在哪个 CPU 上运行？任务之间是否需要相邻运行？哪些先运行？哪些后运行？都由调度器统一调度，任务基于协程实现。在任务阻塞时，快速让出 CPU。每个物理 CPU 上除运行1个 normal 级别的 thread 外，运行着另外 1+ 个高优先级的 thread，基于此，实现用户空间的高优先级的任务抢占运行。比如，之前去 GPU 运行的算法，在 GPU 上完成运行返回后，应该尽快的得到运行。这种调度策略，很好的结合了业务逻辑、数据共享和算力的平衡。并且任务不会在不同 CPU 上随机的调度来调度去，具有非常好的 Cache 友好性。
任务编排策略，不仅需要对业务逻辑的深度理解，也需要结合计算机的算力等综合考虑。因此，Cyber RT 也提供了类似经典线程池模式的调度算法，这种模式几乎不存在配置的代价。对此，Cyber RT 也做了一些改进，比如为了减小锁的瓶颈，任务是多队列的。任务队列也支持优先级，后续还会支持分组，通过组控制算法对资源的使用。
6. 计算模型之上是接口
7. 为什么使用协程，切换速度快，调度的确定性是两个重要的原因。


